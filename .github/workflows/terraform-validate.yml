# Fichier : .github/workflows/terraform-pipeline.yml
name: Terraform CI/CD Pipeline

on:
  push:
    branches:
      - main
      - staging
  pull_request:
    branches:
      - main
      - staging

permissions:
  id-token: write # nécessaire pour l’authentification `OIDC` AWS
  contents: read # nécessaire pour `actions/checkout`
  pull-requests: write # nécessaire pour commenter les PR
  actions: read # nécessaire pour télécharger des artefacts
  deployments: write # nécessaire pour interagir avec les environnements GitHub

jobs:
  validate-code:
    name: Validate Terraform Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::148867357643:role/GitHubActions-Terraform-Role-Projet1 # !! remplacez par l’ARN de votre rôle !!
          aws-region: eu-west-3
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.1" # spécifiez la version de `Terraform` à utiliser
      - name: Terraform Init (validation mode)
        run: terraform init -backend=false -input=false
      - name: Terraform Format Check
        run: terraform fmt -check -recursive -diff
      - name: Terraform Validate
        run: terraform validate
      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: v0.58.0 # spécifiez la version de `TFLint` à utiliser
      - name: Init TFLint
        run: tflint --init
      - name: Run TFLint
        run: tflint --recursive --disable-rule=terraform_unused_declarations
      - name: Run Trivy IaC scan
        uses: aquasecurity/trivy-action@0.30.0
        with:
          scan-type: "config"
          input: "."
          format: "table"
          exit-code: "0" # ne pas échouer le job si des vulnérabilités sont trouvées
          severity: "CRITICAL"
          ignore-unfixed: true
 #Job 2 -> Terraform Plan
  terraform_plan:
    name: Generate Terraform Plan
    runs-on: ubuntu-latest
    needs: validate-code
    if: ${{ github.event_name == 'pull_request' }}
    outputs: # rendre le nom du fichier de plan binaire et le workspace disponibles
      plan_binary_filename: ${{ steps.plan.outputs.PLAN_BINARY_FILENAME }}
      tf_workspace: ${{ steps.set_workspace.outputs.tf_workspace }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::148867357643:role/GitHubActions-Terraform-Role-Projet1 # !! remplacez par l’ARN de votre rôle !!
          aws-region: eu-west-3
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.1" # spécifiez la version de `Terraform` à utiliser
      - name: Determine Terraform workspace
        id: set_workspace
        run: |
          # déterminer le workspace Terraform en fonction de la branche de base de la PR
          if [ "${{ github.base_ref }}" = "main" ]; then
            WORKSPACE=prod
          elif [ "${{ github.base_ref }}" = "staging" ]; then
            WORKSPACE=dev
          else
            WORKSPACE=dev
          fi
          echo "WORKSPACE=$WORKSPACE" >> $GITHUB_ENV
          echo "tf_workspace=$WORKSPACE" >> $GITHUB_OUTPUT
      - name: Terraform Init (for plan)
        id: init_plan
        run: terraform init -input=false
        # ici, nous initialisons le backend car le plan en a besoin pour lire l’état actuel
      - name: Select Terraform workspace
        run: |
          echo "Selecting workspace : $WORKSPACE"
          terraform workspace select $WORKSPACE || terraform workspace new $WORKSPACE
      - name: Terraform Plan
        id: plan
        run: |
          PLAN_BINARY_FILENAME="tfplan-${WORKSPACE}.binary"
          PLAN_TEXT_FILENAME="tfplan-${WORKSPACE}.txt"
          echo "PLAN_BINARY_FILENAME=${PLAN_BINARY_FILENAME}" >> $GITHUB_OUTPUT # exporter le nom du fichier binaire

          echo "--- running terraform plan ---"
          terraform plan -input=false -no-color -out=$PLAN_BINARY_FILENAME -detailed-exitcode > $PLAN_TEXT_FILENAME
          PLAN_COMMAND_RAW_EXIT_CODE=$?
          echo "terraform plan command raw exit code : $PLAN_COMMAND_RAW_EXIT_CODE"

          echo "--- content of $PLAN_TEXT_FILENAME (first 50 lines) ---"
          head -n 50 $PLAN_TEXT_FILENAME
          echo "--- end of $PLAN_TEXT_FILENAME preview ---"

          FINAL_PLAN_DETAILS="vérification manuelle du plan requise (analyse du contenu ou code de sortie non concluant)." # valeur par défaut

          if [ "$PLAN_COMMAND_RAW_EXIT_CODE" -eq 1 ]; then
            FINAL_PLAN_DETAILS="❌ erreur critique lors de la génération du plan (terraform a retourné le code : $PLAN_COMMAND_RAW_EXIT_CODE)"
          elif grep -q -E "(No changes\. Infrastructure is up-to-date\.|No changes\. Your infrastructure matches the configuration\.|Plan: 0 to add, 0 to change, 0 to destroy\.)" $PLAN_TEXT_FILENAME; then
            FINAL_PLAN_DETAILS="✅ aucun changement détecté (confirmé par l’analyse du contenu du plan)."
          elif PLAN_SUMMARY_LINE=$(grep -E "^Plan: ([0-9]+ to add, [0-9]+ to change, [0-9]+ to destroy\.)$" $PLAN_TEXT_FILENAME) && \
               (echo "$PLAN_SUMMARY_LINE" | grep -q -E "([1-9][0-9]* to add|[1-9][0-9]* to change|[1-9][0-9]* to destroy)"); then
            ADD=$(echo "$PLAN_SUMMARY_LINE" | sed -n 's/^Plan: \([0-9]*\) to add,.*/\1/p')
            CHANGE=$(echo "$PLAN_SUMMARY_LINE" | sed -n 's/^Plan: [0-9]* to add, \([0-9]*\) to change,.*/\1/p')
            DESTROY=$(echo "$PLAN_SUMMARY_LINE" | sed -n 's/^Plan:.*, \([0-9]*\) to destroy.$/\1/p')
            FINAL_PLAN_DETAILS="⚠️ changements détectés (analyse du résumé : $ADD à ajouter, $CHANGE à modifier, $DESTROY à détruire). voir l’artéfact."
          else
            echo "warning : contenu du plan ambigu pour la détection automatisée des changements. code de sortie brut de tf : $PLAN_COMMAND_RAW_EXIT_CODE."
            if [ "$PLAN_COMMAND_RAW_EXIT_CODE" -eq 0 ] || [ "$PLAN_COMMAND_RAW_EXIT_CODE" -eq 2 ]; then
              FINAL_PLAN_DETAILS="plan généré (code tf : $PLAN_COMMAND_RAW_EXIT_CODE), mais contenu non analysable automatiquement. vérification manuelle requise."
            fi
          fi
          echo "PLAN_DETAILS=${FINAL_PLAN_DETAILS}" >> $GITHUB_OUTPUT
          echo "final PLAN_DETAILS set to : ${FINAL_PLAN_DETAILS}"

          if [ "$PLAN_COMMAND_RAW_EXIT_CODE" -eq 1 ]; then
            exit 1
          fi
        continue-on-error: true
      - name: Comment PR with plan output
        if: always()
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            ### 📝 résultat du `terraform plan` pour le workspace `${{ steps.set_workspace.outputs.tf_workspace }}`
            ${{ steps.plan.outputs.PLAN_DETAILS }}
            le plan complet (`${{ steps.plan.outputs.plan_binary_filename }}.txt`) et le plan binaire (`${{ steps.plan.outputs.plan_binary_filename }}`) sont disponibles en tant qu’artéfacts.
            **veuillez examiner attentivement le plan avant d’approuver cette PR.**
      - name: Upload Terraform Plan Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ steps.set_workspace.outputs.tf_workspace }}
          path: |
            tfplan-${{ steps.set_workspace.outputs.tf_workspace }}.binary
            tfplan-${{ steps.set_workspace.outputs.tf_workspace }}.txt
          retention-days: 7
          if-no-files-found: ignore

   #Job 3 -> Terraform Apply       
  terraform_apply_staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validate-code] # dépend de la validation. le plan est régénéré.
    if: ${{ github.ref == 'refs/heads/staging' && github.event_name == 'push' }}
    environment:
      name: staging
      url: ${{ steps.get_app_url_staging.outputs.app_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::148867357643:role/GitHubActions-Terraform-Role-Projet1 # !! remplacez par l’ARN de votre rôle !!
          aws-region: eu-west-3
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.1" # spécifiez la version de `Terraform` à utiliser
      - name: Terraform Init
        run: terraform init -input=false
      - name: Select Staging Workspace
        run: terraform workspace select dev || terraform workspace new dev
      - name: Terraform Plan for Staging
        id: plan_staging
        run: |
          terraform plan -input=false -no-color -out=tfplan-staging.binary
          terraform show -no-color tfplan-staging.binary > tfplan-staging.txt
          if grep -q "resources to be destroyed" tfplan-staging.txt; then
            echo "::warning title=changements destructeurs détectés::le plan pour staging contient des destructions. vérification manuelle recommandée."
          fi
          echo "plan_file=tfplan-staging.binary" >> $GITHUB_OUTPUT
      - name: Terraform Apply to Staging
        run: terraform apply -input=false ${{ steps.plan_staging.outputs.plan_file }}
      - name: récupérer l’IP et formater la sortie
        id: get_app_url_staging
        run: |
          # désactiver l’arrêt automatique pour gérer l’absence d’output
          set +e
          APP_IP=$(terraform output -raw web_server_public_ip)
          RETCODE=$?
          set -e

          if [ $RETCODE -ne 0 ] || [ -z "$APP_IP" ]; then
            echo "# la sortie Terraform n’existe pas ou est vide"
            echo "app_url=non-disponible" >> $GITHUB_OUTPUT
            echo "url de l’application (staging) : non-disponible"
          else
            echo "app_url=http://${APP_IP}" >> $GITHUB_OUTPUT
            echo "url de l’application (staging) : http://${APP_IP}"
          fi

  terraform_apply_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [terraform_apply_staging] # dépend d’un déploiement réussi sur staging
    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    environment:
      name: production
      url: ${{ steps.get_app_url_prod.outputs.app_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::472910743243:role/GitHubActions-Terraform-Role-Projet1 # !! remplacez par l’ARN de votre rôle !!
          aws-region: eu-west-3
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.1" # spécifiez la version de `Terraform` à utiliser
      - name: Terraform Init
        run: terraform init -input=false
      - name: Select Production Workspace
        run: terraform workspace select prod || terraform workspace new prod
      - name: Terraform Plan for Production
        id: plan_prod
        run: |
          terraform plan -input=false -no-color -out=tfplan-prod.binary
          terraform show -no-color tfplan-prod.binary > tfplan-prod.txt
          if grep -q "resources to be destroyed" tfplan-prod.txt; then
            echo "::error title=changements destructeurs détectés en production !::le plan pour production contient des destructions. annulation du déploiement automatique."
            # exit 1 # décommentez pour faire échouer le `job` si des destructions sont détectées
          fi
          echo "plan_file=tfplan-prod.binary" >> $GITHUB_OUTPUT
      - name: Terraform Apply to Production
        run: terraform apply -input=false ${{ steps.plan_prod.outputs.plan_file }}
      - name: récupérer l’IP et formater la sortie (production)
        id: get_app_url_prod
        run: |
          # désactiver l’arrêt automatique pour gérer l’absence d’output
          set +e
          APP_IP=$(terraform output -raw web_server_public_ip)
          RETCODE=$?
          set -e

          if [ $RETCODE -ne 0 ] || [ -z "$APP_IP" ]; then
            echo "# la sortie Terraform n’existe pas ou est vide"
            echo "app_url=non-disponible" >> $GITHUB_OUTPUT
            echo "url de l’application (production) : non-disponible"
          else
            echo "app_url=http://${APP_IP}" >> $GITHUB_OUTPUT
            echo "url de l’application (production) : http://${APP_IP}"
          fi          